# KMP算法

# 1. 概述

KMP算法主要应用在字符匹配上。

>Java的String封装了一个indexof方法，底层是普通的暴力搜索。

KMP的主要思想是**当出现字符串不匹配时，可以知道一部分之前已经匹配的文本内容，可以利用这些信息避免从头再去做匹配了。**

## 1.1 前缀表

**前缀表是用来回退的，它记录了模式串与主串(文本串)不匹配的时候，模式串应该从哪里开始重新匹配。**

KMP中的前缀表：**记录下标i之前（包括i）的字符串中，有多大长度的相同前缀后缀。**

例如：给定模式串 "aabaaf" ，对应的前缀表为[0, 1, 0, 1, 2, 0]

## 1.2 最长公共前后缀

字符串的**前缀是指不包含最后一个字符的所有以第一个字符开头的连续子串。后缀是指不包含第一个字符的所有以最后一个字符结尾的连续子串**。

前缀表要求的就是相同前后缀的长度。

next数组就可以是前缀表，但是很多实现都是把前缀表统一减一（右移一位，初始位置为-1）之后作为next数组。例如：模式串 "aabaaf"对应的next数组为[-1, 0, 1,  0, 1, 2], 注意此时next[2]=1代表的意思是字符'b'前面的子串"aa"的最长公共前后缀为"a"，长度为1。

# 2. Java实现

## 2.1 主体部分

```java
public int KMPsearch(String source, String pattern){
    char[] S = source.toCharArray(), P = pattern.toCharArray();
    int i = 0, j = 0;   // i和j分别代表主串和子串的指针
    int[] next = getNext(pattern);  // next数组
    while (i < S.length && j < P.length){
        if (j == -1 || S[i] == P[j]){
            // 由于在next数组中,next[0]定义为-1,所以第一个位置发生不匹配的时候，需要移位
            i++;
            j++;
        }else{
            // i不需要回溯, j回到next数组指定的位置
            j = next[j];
        }
    }
    return j == P.length ? i - j : -1;
}
```

注意最终返回的子串匹配位置不是主串指针i，而是**i - j**，这是因为从i开始需要经过匹配一整个子串，最终i指针的位置是匹配起始位置后移pLen。

## 2.2 求next数组

1. 初始化next数组

初始化字符指针 j = 0，最长公共前后缀k = -1，手动定义next[0] = -1，给定字符串转换的字符数组p, 对应长度是pLen。

> 这种初始化的情况下，很显然第一个过程会有next[1] = 0以及k = 0
> 那么寻找最长公共前后缀的工作就变成了：
> 比较p[j] == p[k]，如果相等，则最长公共前后缀的长度k+1；否则k需要进行回退。

2. 确定循环条件

定义了字符指针j，并且j是从0开始的，所以j应该处于[0, pLen - 1]。

但是我们在下面填入next数组时，是根据前j个字符子串确定next[j+1]的值，所以在j = pLen-2的时候就可以确定next[pLen - 1]的值，此时next数组已经得到，不需要再进行计算，应该跳出。所以最终的循环条件应该是：

```java
while (j < pLen - 1)
```

3. 匹配字符相同（p[j] == p[k]）

匹配字符相同就说明最长公共前后缀长度k需要增加1，并且字符指针j也需要向后移动移位。

此时填入next数组的值为next[j+1] = next[j] + 1 = k+1

> 证明：
> 	在 P[j] 之前已经有 P[0 ~ k-1] == p[j-k ~ j-1]。（next[j] == k）
> 	这时候现有P[k] == P[j]，可以得到P[0 ~ k-1] + P[k] == p[j-k ~ j-1] + P[j]。
> 	即：P[0 ~ k] == P[j-k ~ j]，即next[j+1] == k + 1 == next[j] + 1。

```java
if (k == -1 || p[j] == p[k]){	// 注意当k = -1时表示没有公共前后缀，此时j必须后移
    j++;
    k++;
    next[j] = k;	// 可以简化为一行：next[++j] = ++k;
}
```

4. 匹配字符不相同（p[j] != p[k]）

匹配字符不相同则说明当前不存在长度大于k的最长公共前后缀，故需要对k进行回退。

回退的方法是直接找p[0 ~ k-1]内的最长公共前缀，将k移到此最长公共前缀的末尾位置。

```java
else{
    k = next[k];
}
```

5. 优化

假设有主串"ABACBCDHI"，子串"ABAB"。对子串求next数组为{-1, 0, 0, 1}。

![kmp优化例1](img/kmp优化例1.png)

此时j=3发生字符不匹配，应该取next[3]=1从而移动j指针，得到以下情况：

![kmp优化例2](img/kmp优化例2.png)

注意到，刚刚字符不匹配的情况就是主串的"C"和子串的"B"作比较，获取next值之后仍然是这两个值作比较。这一步是完全没有意义的。因为后面的B已经不匹配了，那前面的B也一定是不匹配的。

所以此处应该增加一个判断条件：匹配字符相同时，检查p[j] == p[k] ? 如果不相等，可以按照之前的方法直接赋值next[j] = k；否则，我们需要继续递归前缀索引，忽略当前的最长公共前后缀，转而找p[0 ~ k-1]内的最长公共前缀，即next[j] == next[k]。

```java
if (k == -1 || p[j] == p[k]){
    k++;
    j++;
    if (p[j] != p[k]){
        next[j] = k;
    }else {
        // 当两个字符相等时要跳过
        next[j] = next[k];
    }
}

// 简化版本
if (k == -1 || p[j] == p[k]){
    if (p[++j] != p[++k]){
        next[j] = k;
    }else {
        next[j] = next[k];
    }
}
```

